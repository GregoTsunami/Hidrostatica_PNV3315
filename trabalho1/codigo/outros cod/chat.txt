def tridiagonal(a, b, c, d):
    n = len(d)
    c_ = [0] * n
    d_ = [0] * n
    x = [0] * n

    c_[0] = c[0] / b[0]
    d_[0] = d[0] / b[0]

    for i in range(1, n):
        temp = b[i] - a[i] * c_[i - 1]
        c_[i] = c[i] / temp
        d_[i] = (d[i] - a[i] * d_[i - 1]) / temp

    x[n - 1] = d_[n - 1]

    for i in range(n - 2, -1, -1):
        x[i] = d_[i] - c_[i] * x[i + 1]

    return x

def cubic_spline(x, y):
    n = len(x)
    h = [x[i + 1] - x[i] for i in range(n - 1)]

    # Construindo a matriz tridiagonal
    a = [0] + [h[i - 1] for i in range(1, n - 1)]
    b = [1] + [2 * (h[i - 1] + h[i]) for i in range(1, n - 1)] + [1]
    c = [h[i] for i in range(n - 2)] + [0]

    # Calculando as diferenças divididas
    delta = [(y[i + 1] - y[i]) / h[i] for i in range(n - 1)]

    # Resolvendo o sistema tridiagonal para obter os coeficientes
    m = tridiagonal(a, b, c, delta)

    # Calculando os coeficientes para cada spline
    coefficients = []
    for i in range(n - 1):
        a = y[i]
        b = delta[i] - h[i] / 3 * (2 * m[i] + m[i])
        c = m[i]
        d = (m[i] - m[i]) / (3 * h[i])
        coefficients.append((a, b, c, d))

    return coefficients

def evaluate_spline(x, coefficients, x_eval):
    for i in range(len(x) - 1):
        if x[i] <= x_eval <= x[i + 1] or (i == len(x) - 2 and x_eval == x[i + 1]):
            a, b, c, d = coefficients[i]
            dx = x_eval - x[i]
            return a + b * dx + c * dx ** 2 + d * dx ** 3

# Calculando os coeficientes da spline cúbica
coefficients = cubic_spline(x, y)

# Avaliando a spline em pontos específicos
x_values = np.linspace(min(x), max(x), 100)
y_values = [evaluate_spline(x, coefficients, val) for val in x_values]

# Plotando os pontos originais
plt.scatter(x, y, color='red', label='Pontos Originais')

# Plotando a spline cúbica
plt.plot(x_values, y_values, label='Spline Cúbica')

# Configurações do gráfico
plt.title('Spline Cúbica')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.grid(True)

# Exibindo o gráfico
plt.show()