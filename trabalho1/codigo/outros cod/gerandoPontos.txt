import pandas as pd
import numpy as np
from math import sqrt
import matplotlib.pyplot as plt
from matplotlib import pyplot, transforms

#lê a planilha do excel
ct = pd.read_excel('Dunkerque.xlsx', sheet_name='BxWL')

#BALIZAS#
#####################
vetX = pd.read_excel('Dunkerque.xlsx', sheet_name='BxWL', usecols="A", skiprows=0) #pega a coluna das balizas
x = vetX.values.flatten() #pega as balizas e joga os valores num vetor

#WL#
#####################
#pega a linha das WL
vetZ = pd.read_excel('Dunkerque.xlsx', sheet_name='BxWL', header=None)
z = vetZ.iloc[0].drop(vetZ.columns[0]).values.flatten()


def splcubic(x,y):
    #lê o tamanho do vetor X
    n = len(x)

    #pega o dicionário para ler a posição e o valor dela na matriz
    #ak = yk
    a= {k: v for k, v in enumerate(y)}
    #hk = xk+1 - xk (distância entre X1 e X2, X2 e X3...)
    h = {k: x[k+1] - x[k] for k in range(n - 1)}


    #[A]*[C] = [B]
    #A=
    #   | 1         0               0               0   |               | c |               |                     0                     |
    #   | h0    2(hk-1 + hk)          hk            0   |       *       | c |       =       |    3/hk (ak+1 - ak) - 3/hk-1 (ak - ak-1)  |
    #   | 0         h1          2(hk + hk+1)      hk+1  |               | c |               | 3/hk+! (ak+2 - ak+1) - 3/hk+1 (ak+1 - ak) |
    #   | 0         0               0               1   |               | c |               |                     0                     |

    A = [ [1] + [0]*(n-1)]
    for k in range(1, (n-1)):
        linha = [0] * n
        linha[k-1] = h[k-1]
        linha[k] = 2*(h[k-1] + h[k])
        linha[k+1] = h[k]
        A.append(linha)
    A.append([0]*(n-1) + [1])

    B = [0]
    for k in range(1, (n-1)):
        linha = ((3/h[k])*(a[k+1] - a[k])) - ((3/h[k-1])*(a[k] - a[k-1]))
        B.append(linha)
    B.append(0)

    #Resolvendo para [C]:
    C = np.linalg.solve(A, B)
    c = {k: v for k, v in enumerate(C)} #faz um dicionário para ver a posição e o valor de c0, c1, c2...

    #Calculando bk = ((1/hk)*(ak+1 - ak)) - ((hk/3)*(2*ck + ck+1)):
    b = {} #cria um dicionário para b
    for k in range(n-1):
        b[k] = ((1/h[k])*(a[k+1] - a[k])) - ((h[k]/3) *(2*c[k] + c[k+1]))

    #Calculando dk = (ck+1 - ck)/3*hk
    d = {} #cria um dicionário para d
    for k in range(n-1):
        d[k] = (c[k+1] - c[k])/(3*h[k])


    #Obtendo as equações para S(x)
    S = {} #cria um dicionário para S
    for k in range(n-1):
        eq = f'{a[k]}{b[k]:+}*(x-{x[k]}){c[k]:+}*(x-{x[k]})**2{d[k]:+}*(x-{x[k]})**3'
        S[k] = {'eq': eq, 'domain':[x[k], x[k+1]]}

        # S[k] = a[k] + (b[k]*(x-x[k])) + (c[k]*(x-x[k])**2) + (d[k]*(x-x[k])**3)
        for key, value in S.items():
            def p(x):
                q = eval(value['eq'])
                return q
        t = np.linspace(*value['domain'], 100)
        plt.plot(t, p(t), label=f"$S_{key}(x)$")
    
    #armazena e guarda as equações splines
    vetS = []
    for k in range(n-1):
        eq = f'{a[k]}{b[k]:+}*(x-{x[k]}){c[k]:+}*(x-{x[k]})**2{d[k]:+}*(x-{x[k]})**3'
        vetS.append(eq)
    
    #pega os pontos intermediários das splines (0,5)
    points = []
    for k in range(n-1):
        eq = f'{a[k]}{b[k]:+}*(x-{x[k]}){c[k]:+}*(x-{x[k]})**2{d[k]:+}*(x-{x[k]})**3'
        mid_x = (x[k] + x[k+1]) / 2
        z_val = eval(eq.replace('x', str(mid_x)))
        points.append([mid_x, a[k], z_val])
    
    return points

#Placeholder pra coletar todos os pontos
all_points = []
#pega todas as meia-bocas de todas WL
for k in range(0, 9):
    wl = k
    y = ct[k].values #une os dados num vetor
    print("\nPara linha d'agua: ", wl)
    print("\nBaliza:", x)
    print("\nMeia-Boca:", y)
    points = splcubic(x, y)
    all_points.extend(points)
    # x0 = 10
    # y0 = splcubic(x,y,x0)
    # print(f'O valor de y para x= {x0} é {y0}')
    # result = splcubic(x,y)
    # S_valores = splcubic(x,y)
plt.ylim(-1, 18)
plt.gca().set_aspect(20/8, adjustable='box')
plt.grid()
plt.xlabel('Baliza')
plt.ylabel('Meia-boca')
plt.show()
print()

#mesma coisa: meia-boca das balizas
for k in range(0,20):
    bl = k
    y = ct.iloc[k].drop(ct.columns[0]).values.flatten()
    print("\nPara baliza: ", bl)
    print("\nLinha D'agua:", z)
    print("\nMeia-boca:", y)
    points = splcubic(z, y)
    all_points.extend(points)
    # z0 = 8
    # y0 = splcubic(z,y,z0)
    # print(f'O valor de y para z= {z0} é {y0}')
    # result = splcubic(z,y)
    # S_valores = splcubic(z,y)
plt.ylim(-1, 16)
plt.gca().set_aspect(9/16, adjustable='box')
plt.grid()
plt.xlabel('WL')
plt.ylabel('Meia-boca')
plt.show()
print()

#Pontos intermediários
for point in all_points:
    print(f"X: {point[0]}, Y: {point[1]}, Z: {point[2]}")



#ideia de painel
def gerar_paineis_por_z(x_spl, y_spl, z_spl):
    paineis_por_z = []
    for i in range(len(z_spl) - 1):
        z = z_spl[i]
        for j in range(len(x_spl) - 1):
            p1 = [x_spl[j], y_spl[j], z]
            p2 = [x_spl[j], y_spl[j], z_spl[i + 1]]
            p3 = [x_spl[j + 1], y_spl[j + 1], z_spl[i + 1]]
            p4 = [x_spl[j + 1], y_spl[j + 1], z]
            paineis_por_z.append([p1, p2, p3, p4])
    return paineis_por_z

# Adaptei a função anterior para gerar painéis ao longo da coordenada Z
# Você precisará fornecer x_spl, y_spl e z_spl interpolados
# Por exemplo:
# x_spl = [-100, -90, -80, -70]
# y_spl = [0, 0, 0, 0]
# z_spl = [1, 2, 3]

paineis = gerar_paineis_por_z(x_spl, y_spl, z_spl)
for painel in paineis:
    print(painel)
