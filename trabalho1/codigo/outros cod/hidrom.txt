
# Cálculo das propriedades hidrostáticas de uma unidade flutuante
# a partir de uma tabela de cotas, utilizando o método dos painéis

import numpy as np
from scipy.interpolate import interp1d

# Leitura do arquivo .txt e coloca tudo numa matriz geral onde retiraremos os dados
geral = np.loadtxt('hidrostatica.txt')

Nwl = int(geral[0, 0])  # numero de linhas D`águas
Nbal = int(geral[0, 1])  # numero de balizas
Deckline = int(geral[0, 2])  # linha no deck (bin)
Contour = int(geral[0, 3])  # linha de contorno (bin)
AftC = int(geral[0, 4])  # linha a Ré (bin)
FwC = int(geral[0, 5])  # linha avante (bin)
FoB = int(geral[0, 6])  # (bin)
precisao = 0.05  # porcentagem do volume
dens = 1.025  # água do mar

# Dados da embarcação
Lwl = geral[0, 7]  # comprimento na Linha d´água do calado
Bwl = geral[0, 8]  # Boca na Linha d´água do calado
Twl = geral[0, 9]  # Calado

# altura das linhas d`águas
Hwl = geral[1, 1:Nwl+1]
distLA = Hwl[1] - Hwl[0]

# distancia das balizas
Bal = geral[3:3+Nbal, 0]
distBAL = Bal[1] - Bal[0]

# linha de contorno de Popa
Cpopa = geral[2, 1:Nwl+1]

# Linha de contorno de Proa
Cproa = geral[3+Nbal, 1:Nwl+1]

# interseção entre as balizas e linhas d`águas (meia-boca)
BW = geral[3:3+Nbal, 1:Nwl+1]

# altura do Deck
Hdeck = geral[3:3+Nbal, Nwl+1]

# Meia-boca do Deck
Bdeck = geral[3:3+Nbal, Nwl+2]

# altura Inicial de cada Baliza
Hbal = geral[3:3+Nbal, Nwl+3]

if np.min(Cpopa) < 0:
    L = abs(np.min(Cpopa)) + np.max(Cproa)
else:
    L = np.max(Cproa) - np.min(Cpopa)

# SPLINES
# calcula as splines referentes às balizas da tabela de cotas
BALsp = []
for j in range(Nbal):
    Hwlaux = [Hbal[j]] + list(Hwl) + [Hdeck[j]]
    BWaux = [0.0] + list(BW[j, :]) + [Bdeck[j]]
    k = 1
    while k <= len(Hwlaux) - 1:  # para todas as cotas
        if Hwlaux[k+1] <= Hwlaux[k]:
            BWaux.pop(k+1)  # remove os zeros excessivos
            Hwlaux.pop(k+1)
        else:
            k += 1
    BALsp.append(interp1d(Hwlaux, BWaux, kind='cubic'))  # monta a referida spline interpolante

# calcula as splines referentes às linhas d'água da tabela de cotas
LAsp = []
for j in range(Nwl):
    Balaux = list(Bal)
    BWaux = list(BW[:, j])
    k = 1
    while k <= len(Balaux) - 1:  # para todas as cotas
        if BWaux[k] <= 0:
            if Balaux[k] < L/2:
                if BWaux[k+1] <= 0:
                    BWaux.pop(k)  # remove os zeros excessivos
                    Balaux.pop(k)
                else:
                    Balaux[k] = Cpopa[j]  # linha a partir da linha de popa
                    k += 1
            else:
                if BWaux[k+1] <= 0:
                    BWaux.pop(k+1)  # remove os zeros excessivos
                    Balaux.pop(k+1)
                    Balaux[k] = Cproa[j]  # linha vai até a linha proa
        else:
            k += 1
    if Balaux[-1] < Cproa[j]:
        Balaux.append(Cproa[j])
        BWaux.append(0)
    LAsp.append(interp1d(Balaux, BWaux, kind='cubic'))  # monta a referida spline interpolante

# plota as BAL originais
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
for k in range(len(Bal)):
    Hwlaux = np.arange(Hbal[k], Hdeck[k], 0.01)
    z = np.ones(len(Hwlaux)) * Bal[k]
    eixox = BALsp[k](Hwlaux)
    eixox = np.where(eixox < 0, 0, eixox)  # elimina qqr numero negativo gerado
    ax.plot(eixox, Hwlaux, z)
ax.set_xlim(0, max(Bdeck)+1)
ax.set_aspect('equal')
plt.show()

# plota as LA originais
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
for k in range(len(Hwl)):
    Balaux = np.arange(Cpopa[k], Cproa[k], 0.01)
    z = np.ones(len(Balaux)) * Hwl[k]
    eixox = LAsp[k](Balaux)
    eixox = np.where(eixox < 0, 0, eixox)  # elimina qqr numero negativo gerado
    ax.plot(eixox, Balaux, z)
ax.set_xlim(0, max(Bdeck)+1)
ax.set_aspect('equal')
plt.show()

# calcula spline referente a linha de popa
i = 0
while Hbal[i] > min(Hbal):
    i += 1
Hpopa = [Hbal[i]]
Lpopa = [Bal[i]]
for i in range(Nwl):
    Hpopa.append(Hwl[i])
    Lpopa.append(Cpopa[i])
Hpopa.append(max(Hdeck))
Lpopa.append(min(Cpopa))
Popasp = interp1d(Hpopa, Lpopa, kind='cubic')  # monta a referida spline interpolante

fig = plt.figure()
Haux = np.arange(0, max(Hdeck), 0.1)
eixoz = Popasp(Haux)
plt.plot(eixoz, Haux)
plt.show()

# Calcula spline de proa
i = Nbal - 1
while Hbal[i] > min(Hbal):
    i -= 1
Hproa = [Hbal[i]]
Lproa = [Bal[i]]
for i in range(Nwl):
    Hproa.append(Hwl[i])
    Lproa.append(Cproa[i])
Proasp = interp1d(Hproa, Lproa, kind='cubic')  # monta a referida spline interpolante

fig = plt.figure()
Haux = np.arange(0, max(Hdeck), 0.1)
eixoz = Proasp(Haux)
plt.plot(eixoz, Haux)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

erro = 1
iteracoes = 0
Ideck = np.interp(max(Hdeck), Popasp, max(Hdeck)) # determina ponto de inicio da embarcação
Fdeck = np.interp(max(Hdeck), Proasp, max(Hdeck)) # determina ponto de final da embarcação
Ibal = min(Hbal) # determina ponto inicial da Baliza
Fbal = max(Hdeck) # determina ponto final da Baliza
if Ideck < 0:
    Lmax = abs(Ideck) + Fdeck # Lmax
else:
    Lmax = Fdeck - Ideck
Balaux = [Ideck]

while abs(erro) > precisao: # enquanto o erro entre iterações consecutivas for maior que a precisão definida
    intBAL = np.arange(Ideck, Fdeck, distBAL) # vetor das balizas interpoladas até a posição da ultima baliza com incremento distBAL
    intLA = np.arange(Ibal, Fbal, distLA) # análogo para as LA

    nBALint = len(intBAL) # calcula o número de balizas interpoladas
    nLAint = len(intLA)

    # calcula as splines das BAL interpoladas
    BALspintpts = np.zeros((len(LAsp), len(intBAL)))
    for n in range(len(LAsp)):
        BALspintpts[n, :] = np.interp(intBAL, Hwl, ppval(LAsp[n], intBAL))
        for m in range(len(intBAL)):
            if intBAL[m] < Lmax/2:
                if intBAL[m] < Cpopa[n]:
                    BALspintpts[n, m] = 0
            else:
                if intBAL[m] > Cproa[n]:
                    Balspintpts[n, m] = 0

    BALspint = []
    for q in range(nBALint):
        BALspint.append(spline(Hwl, BALspintpts[q]))

    # calcula as splines das LA interpoladas
    LAspintpts = np.zeros((len(BALsp), len(intLA)))
    for n in range(len(BALsp)):
        LAspintpts[:, n] = np.interp(intLA, Bal, ppval(BALsp[n], intLA))
        for m in range(len(intLA)):
            if intLA[m] < Hbal[n]:
                LAspintpts[m, n] = 0

    LAspint = []
    for p in range(nLAint):
        LAspint.append(spline(Bal, LAspintpts[p]))

    # monta uma nova tabela de cotas com os pontos das splines interpoladas
    intOffset = np.zeros((nLAint, len(intBAL)))
    for i in range(nLAint):
        intOffset[i, :] = np.interp(intBAL, LAspint[i], intBAL)

    # geraPaineis
    X = []
    Y = []
    Z = []
    for i in range(nLAint-1):
        for j in range(nBALint-1):
            if intOffset[i, j] >= 0 and intOffset[i, j+1] >= 0:
                Xtemp = [intBAL[j], intBAL[j], intBAL[j+1], intBAL[j+1]]
                Ytemp = [intOffset[i+1, j], intOffset[i, j], intOffset[i, j+1], intOffset[i+1, j+1]]
                Ztemp = [intLA[i+1], intLA[i], intLA[i], intLA[i+1]]
                X.append(Xtemp)
                Y.append(Ytemp)
                Z.append(Ztemp)

    # geraPaineisdapopa
    for i in range(nLAint-1):
        if intOffset[i, 0] >= 0 and intOffset[i+1, 0] >= 0:
            Xtemp = [intBAL[0], intBAL[0], intBAL[0], intBAL[0]]
            Ytemp = [0, 0, intOffset[i, 0], intOffset[i+1, 0]]
            Ztemp = [intLA[i+1], intLA[i], intLA[i], intLA[i+1]]
            X.append(Xtemp)
            Y.append(Ytemp)
            Z.append(Ztemp)

    # geraPaineisdofundo
    for i in range(nBALint-1):
        if intOffset[0, i] >= 0 and intOffset[0, i+1] >= 0:
            Xtemp = [intBAL[i], intBAL[i], intBAL[i+1], intBAL[i+1]]
            Ytemp = [intOffset[0, i], 0, 0, intOffset[0, i+1]]
            Ztemp = [intLA[0], intLA[0], intLA[0], intLA[0]]
            X.append(Xtemp)
            Y.append(Ytemp)
            Z.append(Ztemp)

    # calcula áreas dos painéis
    Amod = []
    Avec = []
    for i in range(len(X)):
        Pts = np.zeros((4, 3))
        for j in range(4):
            Pts[j, :] = [X[i][j], Y[i][j], Z[i][j]]
        V = np.zeros((4, 3))
        V[0, :] = Pts[1, :] - Pts[0, :]
        V[1, :] = Pts[3, :] - Pts[0, :]
        V[2, :] = Pts[3, :] - Pts[2, :]
        V[3, :] = Pts[1, :] - Pts[2, :]
        Avectemp = (np.cross(V[0, :], V[1, :]) + np.cross(V[2, :], V[3, :])) / 2
        Avec.append(Avectemp)
        Amod.append(np.sqrt(Avectemp[0]**2 + Avectemp[1]**2 + Avectemp[2]**2))

        # calcula momento de inercia próprio de acordo com o material de referência
        base1 = np.sqrt(V[1, 0]**2 + V[1, 1]**2)
        base2 = np.sqrt(V[3, 0]**2 + V[3, 1]**2)
        area1 = np.cross(V[0, :], V[1, :])
        area2 = np.cross(V[2, :], V[3, :])
        haltura1 = np.sqrt(area1[0]**2 + area1[1]**2 + area1[2]**2) / base1
        haltura2 = np.sqrt(area2[0]**2 + area2[1]**2 + area2[2]**2) / base2
        c1 = np.sqrt((V[1, 0] + V[0, 0])**2 + ((V[1, 1] + V[0, 1])**2) - haltura1**2)
        c2 = np.sqrt((V[3, 0] + V[2, 0])**2 + ((V[3, 1] + V[2, 1])**2) - haltura2**2)
        m1 = base1 * haltura1 / 12
        m2 = base2 * haltura2 / 12
        a1 = 3 * base1
        a2 = 3 * base2
        momentox1 = m1 * haltura1**2
        momentox2 = m2 * haltura2**2
        momentoxy1 = m1 * haltura1 * (a1/2 - c1)
        momentoy1 = m1 * (a1 * base1 - a1 * c1 + c1**2)
        momentoy2 = m2 * (a2 * base2 - a2 * c2 + c2**2)
        momentoxy2 = m2 * haltura2 * (a2/2 - c2)
        theta1 = np.arctan(V[1, 0] / V[1, 1])
        theta2 = np.arctan(V[3, 0] / V[3, 1])
        Ipx1 = (momentox1 + momentoy1) / 2 + (momentox1 - momentoy1) * np.cos(2 * theta1) / 2 - momentoxy1 * np.sin(2 * theta1)
        Ipx2 = (momentox2 + momentoy2) / 2 + (momentox2 - momentoy2) * np.cos(2 * theta2) / 2 - momentoxy2 * np.sin(2 * theta2)
        Ipy1 = (momentox1 + momentoy1) / 2 - (momentox1 - momentoy1) * np.cos(2 * theta1) / 2 + momentoxy1 * np.sin(2 * theta1)
        Ipy2 = (momentox2 + momentoy2) / 2 - (momentox2 - momentoy2) * np.cos(2 * theta2) / 2 + momentoxy2 * np.sin(2 * theta2)
        Ipl.append(Ipy1 + Ipy2)
        Ipt.append(Ipx1 + Ipx2)

    # calcula centros dos painéis
    centro = np.zeros((len(X), 3))
    for i in range(len(X)):
        centro[i, 0] = (X[i][0] + X[i][1] + X[i][2] + X[i][3]) / 4
        centro[i, 1] = (Y[i][0] + Y[i][1] + Y[i][2] + Y[i][3]) / 4
        centro[i, 2] = (Z[i][0] + Z[i][1] + Z[i][2] + Z[i][3]) / 4

    # cálculo das propriedades hidrostáticas para os calados interpolados
    Vol = np.zeros(nLAint)
    AMol = np.zeros(nLAint)
    Awl = np.zeros(nLAint)
    LCF = np.zeros(nLAint)
    TCF = np.zeros(nLAint)
    CB = np.zeros((nLAint, 3))
    Tcm = np.zeros(nLAint)
    Cwl = np.zeros(nLAint)
    Il = np.zeros(nLAint)
    It = np.zeros(nLAint)
    desloc = np.zeros(nLAint)
    BMt = np.zeros(nLAint)
    BMl = np.zeros(nLAint)
    Cb = np.zeros(nLAint)

    for i in range(nLAint):
        calcHidros = []
        Lpaineis = []
        Bpaineis = []

        # calcula os painéis envolvidos (abaixo da LA)
        for k in range(len(Z)):
            if Z[k][0] <= intLA[i]:
                calcHidros.append(k)
                Lpaineis.append([X[k][0], X[k][2]])
                Bpaineis.append([Y[k][0], Y[k][2]])

        Voltemp = 0
        AMoltemp = 0
        Awltemp = 0
        Abalcpmtemp = 0
        LCFnumtemp = 0
        TCFnumtemp = 0
        LCBnumtemp = 0
        TCBnumtemp = 0
        KBnumtemp = 0
        Tcmtemp = 0
        Iltemp = 0
        Ittemp = 0

        for j in range(len(calcHidros)):
            Voltemp += (Avec[calcHidros[j]][0] * (0 - centro[calcHidros[j]][0]) + Avec[calcHidros[j]][1] * (0 - centro[calcHidros[j]][1]) + Avec[calcHidros[j]][2] * (intLA[i] - centro[calcHidros[j]][2])) / 3
            AMoltemp += Amod[calcHidros[j]]
            Awltemp += Avec[calcHidros[j]][2]
            if Avec[calcHidros[j]][0] > 0:
                Abalcpmtemp += Avec[calcHidros[j]][0]
            LCFnumtemp += Avec[calcHidros[j]][2] * centro[calcHidros[j]][0]
            TCFnumtemp += Avec[calcHidros[j]][2] * centro[calcHidros[j]][1]
            LCBnumtemp += Avec[calcHidros[j]][0] * (0 - centro[calcHidros[j]][0]) * centro[calcHidros[j]][0] / 2
            TCBnumtemp += Avec[calcHidros[j]][1] * (0 - centro[calcHidros[j]][1]) * centro[calcHidros[j]][1] / 2
            KBnumtemp += Avec[calcHidros[j]][2] * (intLA[i] - centro[calcHidros[j]][2]) * (intLA[i] - centro[calcHidros[j]][2]) / 2

        for j in range(len(calcHidros)):
            Iltemp += Avec[calcHidros[j]][2] * (centro[calcHidros[j]][0] - (LCFnumtemp / Awltemp))**2 + Ipl[calcHidros[j]]
            Ittemp += Avec[calcHidros[j]][2] * (centro[calcHidros[j]][1])**2 + Ipt[calcHidros[j]]

        Vol[i] = 2 * Voltemp
        AMol[i] = 2 * AMoltemp
        Awl[i] = 2 * Awltemp
        Abalcpm[i] = Abalcpmtemp * 2
        LCF[i] = 2 * LCFnumtemp / Awl[i] - Lwl / 2
        TCF[i] = 2 * TCFnumtemp / Awl[i]
        CB[i, 0] = 2 * LCBnumtemp / Vol[i] - Lwl / 2
        CB[i, 1] = 2 * TCBnumtemp / Vol[i]
        CB[i, 2] = 2 * KBnumtemp / Vol[i]
        Il[i] = 2 * Iltemp
        It[i] = 2 * Ittemp
        Tcm[i] = Awl[i] * dens / 100
        Lcalado = max(max(Lpaineis)) - min(min(Lpaineis))
        Bcalado = max(max(Bpaineis)) - min(min(Bpaineis))
        if Bcalado != 0 and Lcalado != 0:
            Cwl[i] = Awl[i] / (2 * Bcalado * Lcalado)
            Cp[i] = Vol[i] / (Abalcpm[i] * Lcalado)
        desloc[i] = Vol[i] * dens
        BMt[i] = It[i] / Vol[i]
        BMl[i] = Il[i] / Vol[i]
        if Bcalado != 0 and Lcalado != 0:
            Cb[i] = Vol[i] / (2 * Bcalado * Lcalado * intLA[i])

    if iteracoes == 0:
        Volumeanterior = Vol[nLAint-1]
    else:
        erro = (Vol[nLAint-1] - Volumeanterior) / Vol[nLAint-1]
        Volumeanterior = Vol[nLAint-1]

    distBAL = distBAL / 2
    distLA = distLA / 2

    iteracoes += 1

distBAL = distBAL * 2
distLA = distLA * 2

# plota as BAL originais
plt.figure()
for k in range(len(Bal)):
    Hwlaux = np.arange(Hbal[k], Hdeck[k], 0.01)
    z = np.ones(len(Hwlaux)) * Bal[k]
    eixox = np.interp(Hwlaux, BALsp[k], Hwlaux)
    eixox[eixox < 0] = 0
    plt.plot(eixox, Hwlaux, z)
    plt.xlim([0, max(Bdeck) + 1])
    plt.gca().set_aspect('equal', adjustable='box')

# plota as BAL interpoladas
plt.figure()
for k in range(nBALint):
    z = np.ones(len(intLA)) * (k - 1) * distBAL
    eixox = np.interp(intLA, BALspint[k], intLA)
    eixox[eixox < 0] = 0
    plt.plot(eixox, intLA, z)
    plt.xlim([0, 2 * Bwl])
    plt.gca().set_aspect('equal', adjustable='box')

# plota as LA originais
plt.figure()
for k in range(len(Hwl)):
    Balaux = np.arange(Cpopa[k], Cproa[k], 0.01)
    Balaux = Balaux[Balaux >= 0]
    z = np.ones(len(Balaux)) * Hwl[k]
    eixox = np.interp(Balaux, LAsp[k], Balaux)
    eixox[eixox < 0] = 0
    plt.plot(eixox, Balaux, z)
    plt.xlim([0, max(Bdeck) + 1])
    plt.gca().set_aspect('equal', adjustable='box')

# plota as LA interpoladas
plt.figure()
for k in range(nLAint):
    z = np.ones(len(intBAL)) * (k - 1) * distLA
    eixox = np.interp(intBAL, LAspint[k], intBAL)
    eixox[eixox < 0] = 0
    plt.plot(eixox, intBAL, z)
    plt.xlim([0, 2 * Bwl])
    plt.gca().set_aspect('equal', adjustable='box')

# plotagem das curvas hidrostáticas
plt.figure()
plt.plot(Vol, intLA, 'b')
plt.plot(AMol, intLA, 'r')
plt.plot(Awl, intLA, 'g')
plt.xlabel('m^2 , m^3')
plt.ylabel('Draught (m)')
plt.legend(['Volume', 'Área Molhada', 'Área da Linha d\'Água'])

plt.figure()
plt.plot(LCF, intLA, 'm')
plt.plot(CB[:, 0], intLA, 'c')
plt.plot(CB[:, 2], intLA, 'k')
plt.xlabel('m')
plt.ylabel('Draught (m)')
plt.legend(['LCF', 'LCB', 'KB'])

plt.figure()
plt.plot(BMt, intLA, 'b')
plt.xlabel('m')
plt.ylabel('Draught (m)')
plt.legend(['BMt'])

plt.figure()
plt.plot(BMl, intLA, 'r')
plt.xlabel('m')
plt.ylabel('Draught (m)')
plt.legend(['BMl'])

plt.figure()
plt.plot(Tcm, intLA, 'k')
plt.xlabel('ton')
plt.ylabel('Draught (m)')
plt.legend(['Tcm'])

plt.figure()
plt.plot(Il, intLA, 'b')
plt.xlabel('m^4')
plt.ylabel('Draught (m)')
plt.legend(['Il'])

plt.figure()
plt.plot(It, intLA, 'r')
plt.xlabel('m^4')
plt.ylabel('Draught (m)')
plt.legend(['It'])

plt.figure()
plt.plot(Cb, intLA, 'b')
plt.plot(Cwl, intLA, 'r')
plt.plot(Cp, intLA, 'g')
plt.ylabel('Draught (m)')
plt.legend(['Cb', 'Cwl', 'Cp'])

plt.show()


