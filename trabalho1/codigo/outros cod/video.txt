# x = np.array([1, 2, 4, 5])
# y = np.array([1, 4, 2, 3])

def splcubica(x,y):
    #retorna ak, bk, ck e dk
    ########################
    
    
    n = len(x)
    a = {k: v for k, v in enumerate(y)} #o dicionário retorna a posição e o valor dela numa matriz (ak = yk)
    h = {k: x[k+1] - x[k] for k in range(n - 1)} #hk = xk+1 - xk


    #[A]*[c] = [B] <==> acharemos [C]
    A = [[1] + [0] * (n-1)]
    for i in range(1, (n-1)):
        linha = [0] * n
        linha[i-1] = h[i-1]
        linha[i] = 2*(h[i-1] + h[i])
        linha[i+1] = h[i]
        A.append(linha)
    A.append([0]*(n-1)+[1])

    B = [0]
    for k in range(1, n-1):
        linha = 3 * (a[k+1]-a[k]) / h[k] - 3 * (a[k] - a[k-1]) / h[k]
        B.append(linha)
    B.append(0)
    
    c = dict(zip(range(n), np.linalg.solve(A, B))) #resolve a equação do sist. linear e mostra num dicionário varrendo todo comprimento de x
    
    
    #para achar b:
    #bk = (1 / hk) * (ak+1 - ak) - (hk / 3) * (2*ck + ck+1)
    b = {}
    for k in range(n-1):
        b[k] = (1/h[k]) * (a[k+1] - a[k]) - (h[k]/3) * (2*c[k]+c[k+1])
    
    
    #para achar d:
    #dk = (ck+1 - ck) / 3*hk
    d = {}
    for k in range(n-1):
        d[k] = (c[k+1] - c[k])/(3*h[k])
    
    #dicionário para me dar os coef de Sk
    S = {}
    for k in range(n-1):
        eq = f'{a[k]}{b[k]:+}*(x-{x[k]}){c[k]:+}*(x-{x[k]})**2{d[k]:+}*(x-{x[k]})**3'
        S[k] = {'eq': eq, 'domain':[x[k], x[k+1]]}
        
    return S

eqs = splcubica(x,y)
print(eqs)


for key, value in eqs.items():
    def p(x):
        q = eval(value['eq'])
        return q
    
    t = np.linspace(*value['domain'], 100)
    plt.plot(t, p(t), label=f"$S_{key}(x)$")
plt.scatter(x,y)
plt.show()